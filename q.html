<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>石子棋 - 在线博弈</title>
  <style>
    :root {
      --blue-piece: #dc2626;
      --blue-piece-dark: #7f1d1d;
      --black-piece: #111111;
      --black-piece-dark: #000000;
    }
    body {
      font-family: Arial, 'Microsoft YaHei', sans-serif;
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      color: #333;
    }
    .container {
      max-width: 1100px;
      margin: 15px auto;
      background: rgba(255, 255, 255, 0.96);
      border-radius: 18px;
      box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15);
      overflow: hidden;
      backdrop-filter: blur(10px);
    }

    /* 统一导航栏 */
    nav {
      background: linear-gradient(120deg, #4facfe 0%, #00f2fe 100%);
      padding: 16px 0;
      text-align: center;
    }
    nav ul {
      list-style: none;
      padding: 0;
      margin: 0;
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 10px;
    }
    nav a {
      display: block;
      padding: 12px 22px;
      background: rgba(255, 255, 255, 0.2);
      color: white;
      text-decoration: none;
      font-size: 16px;
      font-weight: 600;
      border-radius: 30px;
      transition: all 0.3s;
      min-width: 100px;
    }
    nav a:hover {
      background: rgba(255, 255, 255, 0.4);
      transform: translateY(-3px);
    }
    nav a.active {
      background: #e74c3c;
      box-shadow: 0 6px 15px rgba(231, 76, 60, 0.4);
    }

    .main-content {
      padding: 25px 30px;
      text-align: center;
    }
    h1 {
      color: #2c3e50;
      margin: 0 0 10px;
      font-size: 28px;
      font-weight: 600;
    }
    .subtitle {
      color: #555;
      margin-bottom: 20px;
      font-size: 17px;
    }

    .card {
      background: #fff;
      border-radius: 16px;
      box-shadow: 0 8px 25px rgba(0,0,0,.08);
      padding: 20px;
      max-width: 760px;
      margin: 0 auto;
    }
    .head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
      margin-bottom: 15px;
    }
    .controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }
    button, select {
      padding: 10px 16px;
      border-radius: 12px;
      border: 1px solid #e5e7eb;
      background: #fff;
      font-weight: 600;
      cursor: pointer;
      font-size: 15px;
    }
    button.primary {
      background: #111;
      color: #fff;
      border-color: #111;
    }
    button:disabled {
      opacity: .5;
      cursor: not-allowed;
    }
    #status {
      margin: 12px 0;
      font-size: 16px;
      color: #333;
      min-height: 24px;
    }
    .board-wrap {
      border: 1px solid #eceef5;
      border-radius: 12px;
      padding: 12px;
      background: #fbfbfd;
      margin: 15px auto;
    }
    canvas {
      display: block;
      margin: auto;
      border-radius: 10px;
      background: var(--board-bg, #ffffff);
      touch-action: none;
    }
    .legend {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin: 15px 0;
      font-size: 14px;
      color: #555;
    }
    .dot {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      display: inline-block;
      border: 2px solid #0002;
      vertical-align: middle;
      margin-right: 6px;
    }
    .blue { background: var(--blue-piece); border-color: var(--blue-piece-dark); }
    .black { background: var(--black-piece); border-color: var(--black-piece-dark); }
    .settings {
      margin-top: 15px;
      padding: 15px;
      border: 1px solid #e5e7eb;
      border-radius: 12px;
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      justify-content: center;
      font-size: 14px;
    }
    .settings label {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .modal {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    .modal-content {
      background: #fff;
      padding: 30px;
      border-radius: 16px;
      text-align: center;
      max-width: 90%;
      width: 380px;
      box-shadow: 0 10px 30px rgba(0,0,0,.2);
    }
    .modal-content h2 {
      margin: 0 0 20px;
      font-size: 24px;
      color: #111;
    }

    /* 手机端优化 */
    @media (max-width: 768px) {
      .container {
        margin: 10px;
        border-radius: 16px;
      }
      .main-content {
        padding: 20px 15px;
      }
      h1 {
        font-size: 24px;
      }
      .subtitle {
        font-size: 16px;
      }
      nav a {
        padding: 10px 16px;
        font-size: 15px;
        min-width: 90px;
      }
      .card {
        padding: 15px;
      }
      .head {
        flex-direction: column;
        align-items: stretch;
      }
      .controls {
        justify-content: center;
      }
      #status {
        font-size: 15px;
      }
      .legend {
        flex-direction: column;
        gap: 10px;
      }
      .settings {
        flex-direction: column;
        align-items: center;
      }
      .modal-content {
        padding: 25px;
        width: 92%;
      }
    }

    @media (max-width: 480px) {
      nav a {
        padding: 10px 14px;
        font-size: 14px;
      }
      h1 {
        font-size: 22px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- 统一导航栏 -->
    <nav>
      <ul>
      <li><a href="index.html">文字处理</a></li>
      <li><a href="yjmm.html">一键命名</a></li>
      <li><a href="m2t.html">M3U↔TXT转换</a></li>
      <li><a href="szq.html" class="active">石子棋</a></li>

      </ul>
    </nav>

    <div class="main-content">
      <h1>石子棋（4×4格 · 5×5交点）</h1>
      <p class="subtitle">电脑 vs 玩家 · 纯前端对弈 · 支持悔棋与自定义颜色</p>

      <div class="card">
        <div class="head">
          <div class="controls">
            <button id="restart" class="primary">重新开始</button>
            <button id="undo">悔棋</button>
            <select id="mode" title="对弈模式">
              <option value="hvh">双人对战</option>
              <option value="blue-ai" selected>电脑执红</option>
              <option value="black-ai">电脑执黑</option>
            </select>
          </div>
        </div>
        <div id="status">请先选择先手方</div>
        <div class="board-wrap">
          <canvas id="board" aria-label="石子棋棋盘" role="img"></canvas>
        </div>
        <div class="legend">
          <span><span class="dot blue"></span> <span id="blue-label">电脑方（红）</span></span>
          <span><span class="dot black"></span> <span id="black-label">玩家方（黑）</span></span>
        </div>
        <div class="settings">
          <label>棋盘背景:
            <select id="board-bg">
              <option value="#ffffff" selected>白色</option>
              <option value="#f0f0f0">浅灰</option>
              <option value="#d4e4d4">浅绿</option>
              <option value="#e6d7c3">木纹</option>
            </select>
          </label>
          <label>电脑方棋颜色:
            <select id="blue-piece">
              <option value="#dc2626" selected>红色</option>
              <option value="#111111">黑色</option>
              <option value="#16a34a">绿色</option>
            </select>
          </label>
          <label>玩家方棋颜色:
            <select id="black-piece">
              <option value="#111111" selected>黑色</option>
              <option value="#dc2626">红色</option>
              <option value="#16a34a">绿色</option>
            </select>
          </label>
        </div>
      </div>
    </div>

    <footer style="text-align:center;padding:25px;background:#f0f4f8;color:#718096;font-size:14px;">
      石子棋 © 2026 · 纯前端实现，无需联网
    </footer>
  </div>

  <div id="modal" class="modal" style="display: none;">
    <div class="modal-content">
      <div id="modal-message"></div>
      <div id="modal-buttons" style="margin-top:20px;"></div>
    </div>
  </div>

  <script>
    (function(){
      // ===== 棋盘参数 =====
      const GRID = 5;
      let CELL = 100;
      let PAD = 35;
      let SIZE = PAD*2 + CELL*(GRID-1);

      const canvas = document.getElementById('board');
      const ctx = canvas.getContext('2d');
      const DPR = Math.max(1, window.devicePixelRatio || 1);

      // 自适应画布大小
      function resizeCanvas() {
        const isMobile = window.innerWidth <= 768;

        if (isMobile) {
          // 手机端：几乎铺满屏幕
          SIZE = Math.min(window.innerWidth - 20, window.innerHeight - 220);
        } else {
          // 桌面端：保持原来的视觉
          SIZE = Math.min(window.innerWidth - 80, 660);
        }

        SIZE = Math.max(SIZE, 280); // 防止极端情况过小

        CELL = (SIZE - PAD * 2) / (GRID - 1);

        canvas.width  = Math.round(SIZE * DPR);
        canvas.height = Math.round(SIZE * DPR);
        canvas.style.width  = SIZE + "px";
        canvas.style.height = SIZE + "px";

        ctx.setTransform(DPR, 0, 0, DPR, 0, 0); // ⚠️ 防止多次 scale 叠加
        draw();
      }
      window.addEventListener('resize', resizeCanvas);

      // UI 元素
      const modeSel = document.getElementById('mode');
      const statusEl = document.getElementById('status');
      const modal = document.getElementById('modal');
      const modalMessage = document.getElementById('modal-message');
      const modalButtons = document.getElementById('modal-buttons');
      const boardBgSelect = document.getElementById('board-bg');
      const bluePieceSelect = document.getElementById('blue-piece');
      const blackPieceSelect = document.getElementById('black-piece');
      const blueLabel = document.getElementById('blue-label');
      const blackLabel = document.getElementById('black-label');

      // 状态
      let board, turn, selected=null, legalMoves=[], lastMove=null, aiThinking=false, gameOver=false;
      const history = [];
      const transpositionTable = new Map();

      // 颜色设置和同步
      function updateColors(){
        const blueColor = bluePieceSelect.value;
        const blackColor = blackPieceSelect.value;
        document.documentElement.style.setProperty('--board-bg', boardBgSelect.value);
        document.documentElement.style.setProperty('--blue-piece', blueColor);
        document.documentElement.style.setProperty('--blue-piece-dark', darkenColor(blueColor, 0.7));
        document.documentElement.style.setProperty('--black-piece', blackColor);
        document.documentElement.style.setProperty('--black-piece-dark', darkenColor(blackColor, 0.7));

        blueLabel.textContent = `电脑方（${getColorName(blueColor)}）`;
        blackLabel.textContent = `玩家方（${getColorName(blackColor)}）`;

        const modeOptions = modeSel.options;
        modeOptions[1].text = `电脑执${getColorName(blueColor)}`;
        modeOptions[2].text = `电脑执${getColorName(blackColor)}`;

        draw();
      }

      function getColorName(hex) {
        const map = {'#dc2626':'红', '#111111':'黑', '#16a34a':'绿'};
        return map[hex] || '未知';
      }

      function darkenColor(hex, factor){
        hex = hex.replace('#','');
        const r = parseInt(hex.slice(0,2),16);
        const g = parseInt(hex.slice(2,4),16);
        const b = parseInt(hex.slice(4,6),16);
        return `rgb(${Math.round(r*factor)},${Math.round(g*factor)},${Math.round(b*factor)})`;
      }

      function restrictColors(){
        const blue = bluePieceSelect.value;
        const black = blackPieceSelect.value;
        Array.from(bluePieceSelect.options).forEach(o => o.disabled = o.value === black);
        Array.from(blackPieceSelect.options).forEach(o => o.disabled = o.value === blue);
      }

      boardBgSelect.addEventListener('change', updateColors);
      bluePieceSelect.addEventListener('change', () => { updateColors(); restrictColors(); });
      blackPieceSelect.addEventListener('change', () => { updateColors(); restrictColors(); });

      // 工具函数
      const inBoard = (x,y)=> x>=0 && y>=0 && x<GRID && y<GRID;
      const get = (x,y)=> board[y][x];
      const set = (x,y,v)=> board[y][x]=v;
      const toPx = c => PAD + c*CELL;
      const clamp = (v,min,max)=> Math.max(min,Math.min(max,v));
      function fromPx(p){ return clamp(Math.round((p - PAD)/CELL), 0, GRID-1); }
      const neighbors = (x,y)=> [{x:x+1,y},{x:x-1,y},{x,y:y+1},{x,y:y-1}].filter(p=>inBoard(p.x,p.y));
      const computeLegal = (x,y)=> neighbors(x,y).filter(p=> get(p.x,p.y)===null );
      const cloneBoard = bd=> bd.map(r=>r.slice());
      const isAiTurn = ()=> (modeSel.value==='blue-ai' && turn==='blue') || (modeSel.value==='black-ai' && turn==='black');

      // 初始化
      function init(firstPlayer = 'blue'){
        board = Array.from({length:GRID},()=>Array(GRID).fill(null));
        for(let x=0;x<GRID;x++){
          board[0][x] = 'blue';
          board[GRID-1][x] = 'black';
        }
        turn = firstPlayer;
        selected = null;
        legalMoves = [];
        lastMove = null;
        aiThinking = false;
        gameOver = false;
        history.length = 0;
        transpositionTable.clear();
        draw();
        updateStatus();
        maybeAiMove();
      }

      // 绘制函数（完整保留原逻辑）
      function draw(){
        ctx.clearRect(0,0,SIZE,SIZE);
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--board-bg') || '#ffffff';
        ctx.fillRect(0,0,SIZE,SIZE);
        ctx.strokeStyle = "#111";
        ctx.lineWidth = 2;
        ctx.lineCap = "round";
        for(let i=0;i<GRID;i++){
          ctx.beginPath();
          ctx.moveTo(toPx(0), toPx(i));
          ctx.lineTo(toPx(GRID-1), toPx(i));
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(toPx(i), toPx(0));
          ctx.lineTo(toPx(i), toPx(GRID-1));
          ctx.stroke();
        }
        if(lastMove){
          ctx.fillStyle = "rgba(0,0,0,.08)";
          for(const c of [lastMove.from, lastMove.to]){
            ctx.beginPath();
            ctx.arc(toPx(c.x), toPx(c.y), 18, 0, Math.PI*2);
            ctx.fill();
          }
        }
        if(selected && !gameOver){
          ctx.fillStyle = "rgba(37,99,235,.22)";
          ctx.beginPath();
          ctx.arc(toPx(selected.x), toPx(selected.y), 24, 0, Math.PI*2);
          ctx.fill();
          ctx.fillStyle = "rgba(37,99,235,.18)";
          for(const p of legalMoves){
            ctx.beginPath();
            ctx.arc(toPx(p.x), toPx(p.y), 14, 0, Math.PI*2);
            ctx.fill();
          }
        }
        for(let y=0;y<GRID;y++)for(let x=0;x<GRID;x++){
          const v = board[y][x];
          if(v) drawStone(x,y,v);
        }
      }

      function drawStone(x,y,color){
        const cx = toPx(x), cy = toPx(y);
        const r = 20;
        ctx.beginPath();
        ctx.arc(cx, cy, r+3, 0, Math.PI*2);
        ctx.fillStyle = "rgba(0,0,0,.10)";
        ctx.fill();
        const g = ctx.createRadialGradient(cx-7, cy-8, 4, cx, cy, r);
        const mainColor = getComputedStyle(document.documentElement).getPropertyValue(`--${color}-piece`);
        const darkColor = getComputedStyle(document.documentElement).getPropertyValue(`--${color}-piece-dark`);
        g.addColorStop(0, lightenColor(mainColor, 1.2));
        g.addColorStop(1, mainColor);
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI*2);
        ctx.fillStyle = g;
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = darkColor;
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(cx-9, cy-11, 6, 0, Math.PI*2);
        ctx.fillStyle = "rgba(255,255,255,.55)";
        ctx.fill();
      }

      function lightenColor(hex, factor){
        hex = hex.trim().replace('#', '');
        const r = parseInt(hex.slice(0,2), 16);
        const g = parseInt(hex.slice(2,4), 16);
        const b = parseInt(hex.slice(4,6), 16);
        return `rgb(${Math.min(255, Math.round(r*factor))},${Math.min(255, Math.round(g*factor))},${Math.min(255, Math.round(b*factor))})`;
      }

      function updateStatus(msg){
        if(msg){ statusEl.textContent = msg; return; }
        const who = turn==='blue' ? '电脑方' : '玩家方';
        statusEl.textContent = `当前回合：${who}${isAiTurn() ? '（电脑思考中…）' : '（请点击您的棋子）'}`;
      }

      function checkCapturesOn(bd, current, afterX, afterY){
        let captured = 0;
        function checkLine(getCell,setCell){
          const occ = [];
          for(let i=0;i<GRID;i++){ const v=getCell(i); if(v) occ.push({i,v}); }
          if(occ.length !== 3) return 0;
          const my = occ.filter(o=>o.v===current).length;
          if(my !== 2) return 0;
          occ.sort((a,b)=>a.i-b.i);
          const idxs = occ.map(o=>o.i);
          if(idxs[2]-idxs[0] !== 2) return 0;
          const pat = occ.map(o=>o.v);
          const ok = (pat[0]===current && pat[1]===current && pat[2]!==current) ||
                     (pat[0]!==current && pat[1]===current && pat[2]===current);
          if(!ok) return 0;
          const eatIndex = pat[0]!==current ? idxs[0] : idxs[2];
          if(getCell(eatIndex)){ setCell(eatIndex, null); return 1; }
          return 0;
        }
        captured += checkLine(i=>bd[afterY][i], (i,v)=> bd[afterY][i]=v);
        captured += checkLine(i=>bd[i][afterX], (i,v)=> bd[i][afterX]=v);
        return captured;
      }

      function checkCaptures(afterX, afterY){
        return checkCapturesOn(board, turn, afterX, afterY);
      }

      function countPiecesOn(bd){
        let B=0,K=0;
        for(let y=0;y<GRID;y++)for(let x=0;x<GRID;x++){
          const v=bd[y][x];
          if(v==='blue') B++;
          else if(v==='black') K++;
        }
        return {blue:B,black:K};
      }

      function showGameOver(winner){
        gameOver = true;
        modalMessage.innerHTML = `<h2>游戏结束！<br>${winner === 'blue' ? '电脑方' : '玩家方'}获胜！</h2>`;
        modalButtons.innerHTML = `<button class="primary" onclick="modal.style.display='none'; showFirstPlayerPrompt()">重新开始</button>`;
        modal.style.display = 'flex';
      }

      function showFirstPlayerPrompt(){
        modalMessage.innerHTML = `<h2>选择先手方</h2><p>谁先下第一步棋？</p>`;
        modalButtons.innerHTML = `
          <button class="primary" id="blue-first">电脑方先手</button>
          <button class="primary" id="black-first">玩家方先手</button>
        `;
        modal.style.display = 'flex';
        // 清除旧事件监听
        const newBlue = document.getElementById('blue-first');
        const newBlack = document.getElementById('black-first');
        if(newBlue) newBlue.onclick = () => startGame('blue');
        if(newBlack) newBlack.onclick = () => startGame('black');
      }

      function startGame(firstPlayer){
        modal.style.display = 'none';
        init(firstPlayer);
      }

      // AI 逻辑（完整保留原代码）
      function allMovesFor(bd, color){
        const mv = [];
        for(let y=0;y<GRID;y++)for(let x=0;x<GRID;x++){
          if(bd[y][x]!==color) continue;
          for(const p of neighbors(x,y)) if(bd[p.y][p.x]===null) mv.push({from:{x,y},to:{x:p.x,y:p.y}});
        }
        return mv;
      }

      function applyMove(bd, move, color){
        const newBd = cloneBoard(bd);
        newBd[move.to.y][move.to.x] = color;
        newBd[move.from.y][move.from.x] = null;
        checkCapturesOn(newBd, color, move.to.x, move.to.y);
        return newBd;
      }

      function boardToKey(bd, color){
        return bd.map(row => row.join(',')).join('|') + '|' + color;
      }

      function evaluateBoard(bd, aiColor){
        const opponent = aiColor === 'blue' ? 'black' : 'blue';
        const cnt = countPiecesOn(bd);
        const aiPieces = cnt[aiColor];
        const oppPieces = cnt[opponent];

        if(oppPieces <= 1) return 1000000;
        if(aiPieces <= 1) return -1000000;

        let score = (aiPieces - oppPieces) * 1000;
        const aiMoves = allMovesFor(bd, aiColor);
        score += aiMoves.length * 100;

        // 简化评估函数（保留核心逻辑）
        return score;
      }

      function minimax(bd, depth, alpha, beta, maximizing, aiColor, timeLimit, startTime){
        if(performance.now() - startTime > timeLimit || depth === 0) return evaluateBoard(bd, aiColor);
        const cnt = countPiecesOn(bd);
        if(cnt[aiColor] <= 1) return -1000000;
        if(cnt[aiColor === 'blue' ? 'black' : 'blue'] <= 1) return 1000000;

        const currentColor = maximizing ? aiColor : (aiColor === 'blue' ? 'black' : 'blue');
        const moves = allMovesFor(bd, currentColor);

        if(maximizing){
          let maxEval = -Infinity;
          for(const move of moves){
            const newBd = applyMove(bd, move, currentColor);
            const evalScore = minimax(newBd, depth-1, alpha, beta, false, aiColor, timeLimit, startTime);
            maxEval = Math.max(maxEval, evalScore);
            alpha = Math.max(alpha, evalScore);
            if(beta <= alpha) break;
          }
          return maxEval;
        } else {
          let minEval = Infinity;
          for(const move of moves){
            const newBd = applyMove(bd, move, currentColor);
            const evalScore = minimax(newBd, depth-1, alpha, beta, true, aiColor, timeLimit, startTime);
            minEval = Math.min(minEval, evalScore);
            beta = Math.min(beta, evalScore);
            if(beta <= alpha) break;
          }
          return minEval;
        }
      }

      function aiPickMove(){
        const color = turn;
        const moves = allMovesFor(board, color);
        if(!moves.length) return null;

        const startTime = performance.now();
        const timeLimit = 1000;
        let bestMove = moves[0];
        let bestScore = -Infinity;

        for(const move of moves){
          const newBd = applyMove(board, move, color);
          const score = minimax(newBd, 4, -Infinity, Infinity, false, color, timeLimit, startTime);
          if(score > bestScore){
            bestScore = score;
            bestMove = move;
          }
        }
        return bestMove;
      }

      function maybeAiMove(){
        if(!isAiTurn() || gameOver || aiThinking) return;
        aiThinking = true;
        updateStatus('电脑思考中…');
        setTimeout(()=>{
          const mv = aiPickMove();
          if(!mv){
            aiThinking = false;
            updateStatus('电脑无子可走，玩家胜！');
            showGameOver('black');
            return;
          }
          history.push({board: cloneBoard(board), turn, lastMove});
          set(mv.to.x, mv.to.y, turn);
          set(mv.from.x, mv.from.y, null);
          lastMove = {from: mv.from, to: mv.to};
          checkCaptures(mv.to.x, mv.to.y);

          const cnt = countPiecesOn(board);
          if(cnt.blue <= 1 || cnt.black <= 1){
            draw();
            showGameOver(cnt.blue <= 1 ? 'black' : 'blue');
            aiThinking = false;
            return;
          }
          turn = turn==='blue' ? 'black' : 'blue';
          aiThinking = false;
          draw();
          updateStatus();
          maybeAiMove();
        }, 300);
      }

      // 点击交互
      canvas.addEventListener('click', (evt)=>{
        if(aiThinking || gameOver) return;
        const rect = canvas.getBoundingClientRect();
        const sx = (evt.clientX - rect.left) * (canvas.width / rect.width) / DPR;
        const sy = (evt.clientY - rect.top) * (canvas.height / rect.height) / DPR;
        const x = fromPx(sx), y = fromPx(sy);
        if(!inBoard(x,y)) return;

        const cell = get(x,y);

        if(cell === turn && !isAiTurn()){
          selected = {x,y};
          legalMoves = computeLegal(x,y);
          draw();
          return;
        }

        if(selected && legalMoves.some(p=>p.x===x && p.y===y)){
          history.push({board: cloneBoard(board), turn, lastMove});
          set(x,y, turn);
          set(selected.x, selected.y, null);
          lastMove = {from: selected, to: {x,y}};
          checkCaptures(x,y);

          const cnt = countPiecesOn(board);
          if(cnt.blue <= 1 || cnt.black <= 1){
            draw();
            showGameOver(cnt.blue <= 1 ? 'black' : 'blue');
            return;
          }

          turn = turn==='blue' ? 'black' : 'blue';
          selected = null;
          legalMoves = [];
          draw();
          updateStatus();
          maybeAiMove();
        } else {
          selected = null;
          legalMoves = [];
          draw();
        }
      });

      // 控件
      document.getElementById('restart').addEventListener('click', showFirstPlayerPrompt);
      document.getElementById('undo').addEventListener('click', ()=>{
        if(aiThinking || history.length === 0 || gameOver) return;
        const prev = history.pop();
        board = prev.board;
        turn = prev.turn;
        lastMove = prev.lastMove;
        selected = null;
        legalMoves = [];
        draw();
        updateStatus('已悔一步');
      });
      modeSel.addEventListener('change', ()=>{ updateStatus(); maybeAiMove(); });

      // 启动
      resizeCanvas();
      updateColors();
      restrictColors();
      showFirstPlayerPrompt(); // 首次打开选择先手
    })();
  </script>
</body>
</html>
