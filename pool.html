<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>网上桌球练习台（角度+力度）</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #222;
      color: #eee;
      font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"PingFang SC","Microsoft YaHei",sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 {
      margin: 12px 0 4px;
      font-size: 24px;
    }
    .info {
      font-size: 13px;
      color: #ccc;
      margin-bottom: 10px;
      text-align: center;
      line-height: 1.5;
    }
    canvas {
      background: #155843; /* 典型桌球绿布色 [web:1] */
      border-radius: 16px;
      box-shadow: 0 0 20px rgba(0,0,0,0.8);
      cursor: crosshair;
    }
  </style>
</head>
<body>
  <h1>网上桌球练习台</h1>
  <div class="info">
    鼠标按住白球往后拉：控制击球角度和力度；松开鼠标击球。<br>
    按 R 重置球位。简化物理，仅用于练习瞄准与力度感。
  </div>

  <canvas id="table" width="900" height="450"></canvas>

  <script>
    // ============ 基本配置 ============
    const canvas = document.getElementById('table');
    const ctx = canvas.getContext('2d');

    const TABLE = {
      width: canvas.width,
      height: canvas.height,
      railThickness: 26,
      clothColor: '#155843',
      woodColor: '#5b3a26'
    };

    const BALL_RADIUS = 10;
    const FRICTION = 0.99;   // 摩擦系数 [web:12][web:13]
    const STOP_SPEED = 0.05; // 停止阈值
    const RESTITUTION = 0.98;// 弹性系数，略小于 1 模拟能量损失 [web:12][web:13]

    // ============ 球对象 ============
    class Ball {
      constructor(x, y, color, isCue=false) {
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.color = color;
        this.isCue = isCue;
      }

      speed() {
        return Math.sqrt(this.vx*this.vx + this.vy*this.vy);
      }

      update(dt) {
        // 位置更新
        this.x += this.vx * dt;
        this.y += this.vy * dt;

        // 与库边碰撞（简单弹性反弹）
        const left   = TABLE.railThickness + BALL_RADIUS;
        const right  = TABLE.width - TABLE.railThickness - BALL_RADIUS;
        const top    = TABLE.railThickness + BALL_RADIUS;
        const bottom = TABLE.height - TABLE.railThickness - BALL_RADIUS;

        if (this.x < left) {
          this.x = left;
          this.vx = -this.vx * RESTITUTION;
        } else if (this.x > right) {
          this.x = right;
          this.vx = -this.vx * RESTITUTION;
        }

        if (this.y < top) {
          this.y = top;
          this.vy = -this.vy * RESTITUTION;
        } else if (this.y > bottom) {
          this.y = bottom;
          this.vy = -this.vy * RESTITUTION;
        }

        // 摩擦减速
        this.vx *= FRICTION;
        this.vy *= FRICTION;

        if (this.speed() < STOP_SPEED) {
          this.vx = 0;
          this.vy = 0;
        }
      }

      draw(ctx) {
        // 球体
        const gradient = ctx.createRadialGradient(
          this.x - BALL_RADIUS/3, this.y - BALL_RADIUS/3, 2,
          this.x, this.y, BALL_RADIUS
        );
        gradient.addColorStop(0, '#ffffff');
        gradient.addColorStop(0.2, this.color);
        gradient.addColorStop(1, '#000000');

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, BALL_RADIUS, 0, Math.PI*2);
        ctx.fill();

        // 简单高光
        ctx.fillStyle = 'rgba(255,255,255,0.4)';
        ctx.beginPath();
        ctx.arc(this.x - 3, this.y - 3, 3, 0, Math.PI*2);
        ctx.fill();
      }
    }

    // ============ 场景初始化 ============
    let balls = [];
    let cueBall;

    function resetBalls() {
      balls = [];
      // 母球在左侧开球线
      const cueX = TABLE.railThickness + 120;
      const cueY = TABLE.height / 2;
      cueBall = new Ball(cueX, cueY, '#ffffff', true);
      balls.push(cueBall);

      // 摆一组练习目标球（三角形堆）
      const startX = TABLE.width - TABLE.railThickness - 220;
      const startY = TABLE.height / 2;
      const rowSpacing = BALL_RADIUS * 2.2;
      const colSpacing = BALL_RADIUS * 2.2;

      const colors = [
        '#ffe066', '#6ea0ff', '#ff6b6b', '#c28cff',
        '#ff9f40', '#51cf66', '#a0614b', '#000000'
      ]; // 参考 8 球配色 [web:8]

      let idx = 0;
      for (let row = 0; row < 5; row++) {
        for (let i = 0; i <= row; i++) {
          const x = startX + row * colSpacing;
          const y = startY - rowSpacing * row/2 + i * rowSpacing;
          const color = colors[idx % colors.length];
          balls.push(new Ball(x, y, color, false));
          idx++;
        }
      }
    }

    resetBalls();

    // ============ 鼠标交互：球杆、角度、力度 ============
    let isDragging = false;
    let dragStart = null;   // 鼠标按下位置
    let dragEnd = null;     // 当前鼠标位置
    const MAX_POWER = 1.8;  // 最大力度系数，调大则更“暴力”

    function getMousePos(evt) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: (evt.clientX - rect.left) * (canvas.width / rect.width),
        y: (evt.clientY - rect.top)  * (canvas.height / rect.height)
      };
    }

    canvas.addEventListener('mousedown', (e) => {
      // 若球还在移动，禁止下一杆
      if (balls.some(b => b.speed() > 0)) return;

      const pos = getMousePos(e);
      const dx = pos.x - cueBall.x;
      const dy = pos.y - cueBall.y;
      const dist = Math.sqrt(dx*dx + dy*dy);

      if (dist <= BALL_RADIUS + 12) {
        isDragging = true;
        dragStart = pos;
        dragEnd = pos;
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      dragEnd = getMousePos(e);
    });

    canvas.addEventListener('mouseup', () => {
      if (!isDragging || !dragStart || !dragEnd) return;
      isDragging = false;

      // 力度向量：从鼠标释放点指向拖拽起点（即“往后拉”）
      const dx = dragStart.x - dragEnd.x;
      const dy = dragStart.y - dragEnd.y;
      const dist = Math.sqrt(dx*dx + dy*dy);

      if (dist < 5) return; // 太小当作未击球

      const power = Math.min(dist / 80, MAX_POWER); // 力度归一化 [web:13]
      const angle = Math.atan2(dy, dx);

      const speed = power * 800; // 将力度映射为速度
      cueBall.vx = (speed * Math.cos(angle)) / 60;
      cueBall.vy = (speed * Math.sin(angle)) / 60;

      dragStart = null;
      dragEnd = null;
    });

    // 键盘 R 重置
    window.addEventListener('keydown', (e) => {
      if (e.key === 'r' || e.key === 'R') {
        resetBalls();
      }
    });

    // ============ 球与球碰撞 ============
    function resolveBallCollision(b1, b2) {
      const dx = b2.x - b1.x;
      const dy = b2.y - b1.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      const minDist = BALL_RADIUS * 2;

      if (dist === 0 || dist >= minDist) return;

      // 1. 把球分离开，避免重叠
      const overlap = (minDist - dist) / 2;
      const nx = dx / dist;
      const ny = dy / dist;

      b1.x -= nx * overlap;
      b1.y -= ny * overlap;
      b2.x += nx * overlap;
      b2.y += ny * overlap;

      // 2. 简化：一维弹性碰撞（投影到法线方向） [web:12][web:19]
      const kx = b1.vx - b2.vx;
      const ky = b1.vy - b2.vy;
      const p = 2 * (kx * nx + ky * ny) / 2; // 质量相等

      b1.vx = (b1.vx - p * nx) * RESTITUTION;
      b1.vy = (b1.vy - p * ny) * RESTITUTION;
      b2.vx = (b2.vx + p * nx) * RESTITUTION;
      b2.vy = (b2.vy + p * ny) * RESTITUTION;
    }

    function handleCollisions() {
      for (let i = 0; i < balls.length; i++) {
        for (let j = i+1; j < balls.length; j++) {
          resolveBallCollision(balls[i], balls[j]);
        }
      }
    }

    // ============ 绘制桌面、球袋、球杆等 ============
    function drawTable() {
      ctx.clearRect(0, 0, TABLE.width, TABLE.height);

      // 木质边
      ctx.fillStyle = TABLE.woodColor;
      ctx.fillRect(0, 0, TABLE.width, TABLE.height);

      // 绿色台布
      ctx.fillStyle = TABLE.clothColor;
      ctx.fillRect(
        TABLE.railThickness,
        TABLE.railThickness,
        TABLE.width - TABLE.railThickness*2,
        TABLE.height - TABLE.railThickness*2
      );

      // 球袋位置（6 个）
      const pocketRadius = 16;
      const pockets = [
        {x: TABLE.railThickness, y: TABLE.railThickness},
        {x: TABLE.width - TABLE.railThickness, y: TABLE.railThickness},
        {x: TABLE.railThickness, y: TABLE.height - TABLE.railThickness},
        {x: TABLE.width - TABLE.railThickness, y: TABLE.height - TABLE.railThickness},
        {x: TABLE.width/2, y: TABLE.railThickness-2},
        {x: TABLE.width/2, y: TABLE.height - TABLE.railThickness+2}
      ];
      ctx.fillStyle = '#111';
      pockets.forEach(p => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, pocketRadius, 0, Math.PI*2);
        ctx.fill();
      });

      // 中线
      ctx.strokeStyle = 'rgba(255,255,255,0.2)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(TABLE.width/2, TABLE.railThickness);
      ctx.lineTo(TABLE.width/2, TABLE.height - TABLE.railThickness);
      ctx.stroke();
    }

    function drawCueAndGuide() {
      // 仅在静止 & 拖动时显示球杆
      if (!cueBall || !isDragging || !dragStart || !dragEnd) return;

      const dx = dragStart.x - dragEnd.x;
      const dy = dragStart.y - dragEnd.y;
      const angle = Math.atan2(dy, dx);

      const pullDist = Math.min(
        Math.sqrt(dx*dx + dy*dy),
        MAX_POWER * 80 + 20
      );

      // 球杆前端与母球接触点
      const cueContactX = cueBall.x - Math.cos(angle) * BALL_RADIUS;
      const cueContactY = cueBall.y - Math.sin(angle) * BALL_RADIUS;

      // 球杆后端
      const cueLength = 220;
      const cueBackX = cueContactX - Math.cos(angle) * (cueLength + pullDist);
      const cueBackY = cueContactY - Math.sin(angle) * (cueLength + pullDist);

      // 球杆主体
      ctx.strokeStyle = '#d0b07f';
      ctx.lineWidth = 6;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(cueBackX, cueBackY);
      ctx.lineTo(cueContactX, cueContactY);
      ctx.stroke();

      // 球杆尾部橡胶
      ctx.strokeStyle = '#444';
      ctx.lineWidth = 8;
      ctx.beginPath();
      ctx.moveTo(cueBackX, cueBackY);
      ctx.lineTo(
        cueBackX - Math.cos(angle) * 10,
        cueBackY - Math.sin(angle) * 10
      );
      ctx.stroke();

      // 瞄准辅助线（从母球出发方向）
      const guideLen = 300;
      ctx.strokeStyle = 'rgba(255,255,255,0.4)';
      ctx.lineWidth = 1;
      ctx.setLineDash([8, 6]);
      ctx.beginPath();
      ctx.moveTo(cueBall.x, cueBall.y);
      ctx.lineTo(
        cueBall.x + Math.cos(angle) * guideLen,
        cueBall.y + Math.sin(angle) * guideLen
      );
      ctx.stroke();
      ctx.setLineDash([]);

      // 力度条（右上角）
      const dist = Math.min(Math.sqrt(dx*dx + dy*dy), MAX_POWER*80);
      const powerRatio = dist / (MAX_POWER*80);
      const barWidth = 120;
      const barHeight = 10;
      const margin = 8;

      const x = TABLE.width - TABLE.railThickness - barWidth - margin;
      const y = TABLE.railThickness + margin;
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(x-1, y-1, barWidth+2, barHeight+2);
      ctx.fillStyle = '#555';
      ctx.fillRect(x, y, barWidth, barHeight);
      ctx.fillStyle = '#ffcc33';
      ctx.fillRect(x, y, barWidth * powerRatio, barHeight);

      ctx.fillStyle = '#fff';
      ctx.font = '11px sans-serif';
      ctx.fillText('力度', x, y - 2);
    }

    // ============ 主循环 ============
    let lastTime = null;

    function loop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const dt = (timestamp - lastTime) / 16.67; // 约等于按 60 FPS 标准化

      // 物理更新
      balls.forEach(b => b.update(dt));
      handleCollisions();

      // 绘制
      drawTable();
      balls.forEach(b => b.draw(ctx));
      drawCueAndGuide();

      lastTime = timestamp;
      requestAnimationFrame(loop);
    }

    requestAnimationFrame(loop);
  </script>
</body>
</html>
